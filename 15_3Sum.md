# 🔢 LeetCode 15: 3Sum

![LeetCode](https://img.shields.io/badge/LeetCode-15-blue?style=for-the-badge&logo=leetcode)
![Difficulty](https://img.shields.io/badge/Difficulty-Medium-yellow?style=for-the-badge)
![Topics](https://img.shields.io/badge/Topics-Two%20Pointers%2C%20Sorting-brightgreen?style=for-the-badge)

---

## 📘 Problem Statement

> Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.
>
> **Notice** that the solution set must not contain duplicate triplets.

---

## 📥 Example Inputs

### ✅ Example 1:

**Input:**
```cpp
nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: The distinct triplets [-1, -1, 2] and [-1, 0, 1] sum to zero. The order of triplets in the output doesn't matter.
```
---
```
✅ Example 2:
Input:

nums = [0,1,1]
Output: []
Explanation: No triplet sums to zero.
```
---
```
✅ Example 3:
Input:

nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums to zero.

```

📌 Constraints
3 <= nums.length <= 3000

-10^5 <= nums[i] <= 10^5

---

## 💡 Pattern & Approach
We need **unique triplets** whose sum equals zero.  
A brute-force method (three nested loops) has `O(n³)` complexity — too slow for large inputs.  
The **optimal approach** is to use **sorting** followed by the **two-pointer** technique.

---

## 🔍 The Logic

1. **Sort the Array**  
   Sorting is essential for:
   - Using the two-pointer method efficiently.
   - Easily skipping duplicates.

2. **Outer Loop (Fix One Number)**  
   Iterate with `i` from `0` to `n-3`.  
   `nums[i]` becomes our fixed number **a**.

3. **Two-Pointer Search (Find the Other Two Numbers)**  
   - Left pointer `j = i + 1`  
   - Right pointer `k = n - 1`  
   Goal: Find `nums[j] + nums[k] = -nums[i]`.

4. **While `j < k`**:
   - `sum = nums[i] + nums[j] + nums[k]`
   - If `sum == 0`: 🎯 Found a triplet → Add to result, then skip duplicates for both `j` and `k`.
   - If `sum < 0`: Need a larger sum → `j++`.
   - If `sum > 0`: Need a smaller sum → `k--`.

5. **Skip Duplicates**:
   - **Outer loop**: Skip `nums[i]` if it's the same as the previous `nums[i-1]`.
   - **Inner loop**: Skip `nums[j]` and `nums[k]` duplicates after finding a triplet.

6. **End**  
   Continue until all `i` values are processed.

---

## 🏃‍♂️ Dry Run Example

Given:
nums = [-1, 0, 1, 2, -1, -4]

makefile
Copy
Edit

Sorted:
[-4, -1, -1, 0, 1, 2]

lua
Copy
Edit

| i  | nums[i] | j  | nums[j] | k  | nums[k] | sum  | Action & Skips                                | Result                     |
|----|---------|----|---------|----|---------|------|-----------------------------------------------|----------------------------|
| 0  | -4      | 1  | -1      | 5  | 2       | -3   | sum < 0 → j++                                 | []                         |
| 0  | -4      | 2  | -1      | 5  | 2       | -3   | sum < 0 → j++                                 | []                         |
| 0  | -4      | 3  | 0       | 5  | 2       | -2   | sum < 0 → j++                                 | []                         |
| 0  | -4      | 4  | 1       | 5  | 2       | -1   | sum < 0 → j++                                 | []                         |
| -  | -       | -  | -       | -  | -       | -    | j not < k → End i=0 loop                      | []                         |
| 1  | -1      | 2  | -1      | 5  | 2       | 0    | Found triplet, j++, k--, skip duplicates      | [[-1,-1,2]]                |
| 1  | -1      | 3  | 0       | 4  | 1       | 0    | Found triplet, j++, k--, skip duplicates      | [[-1,-1,2], [-1,0,1]]      |
| -  | -       | -  | -       | -  | -       | -    | j not < k → End i=1 loop                      | [[-1,-1,2], [-1,0,1]]      |
| 2  | -1      | -  | -       | -  | -       | -    | Skip i=2 (duplicate nums[i])                  | [[-1,-1,2], [-1,0,1]]      |
| 3  | 0       | 4  | 1       | 5  | 2       | 3    | sum > 0 → k--                                 | [[-1,-1,2], [-1,0,1]]      |
| -  | -       | -  | -       | -  | -       | -    | j not < k → End i=3 loop                      | [[-1,-1,2], [-1,0,1]]      |
| -  | -       | -  | -       | -  | -       | -    | Outer loop finishes                           | [[-1,-1,2], [-1,0,1]]      |

**Final Answer:** `[[-1, -1, 2], [-1, 0, 1]]`

Export to Sheets

---

💻 C++ Code
C++
```
#include <vector>
#include <algorithm>

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        int n = nums.size();
        
        // Step 1: Sort the array
        sort(nums.begin(), nums.end());
        
        // Step 2: Outer loop to fix the first element of the triplet
        for (int i = 0; i < n - 2; i++) {
            
            // Step 3: Set up two pointers
            int j = i + 1;
            int k = n - 1;
            
            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                
                // Step 4.1: Found a triplet
                if (sum == 0) {
                    result.push_back({nums[i], nums[j], nums[k]});
                    j++;
                    k--;
                    
                    // Skip duplicates for the second element
                    while (j < k && nums[j] == nums[j - 1]) {
                        j++;
                    }
                    // Skip duplicates for the third element
                    while (j < k && nums[k] == nums[k + 1]) {
                        k--;
                    }
                } 
                // Step 4.2: Sum is too large, need to decrease it
                else if (sum > 0) {
                    k--;
                } 
                // Step 4.3: Sum is too small, need to increase it
                else { // sum < 0
                    j++;
                }
            }
            
            // Step 5: Skip duplicates for the first element
            // This moves `i` to the last occurrence of the current number
            // to avoid redundant checks in the next iteration.
            while (i < n - 2 && nums[i] == nums[i + 1]) {
                i++;
            }
        }
        
        return result;
    }
};

```

---
📈 Time & Space Complexity
Complexity	Value	Justification
Time	O(n 
2
 )	The initial sort takes O(n
logn). The nested loops run in O(n 
2
 ) time (O(n) for the outer loop, and O(n) for the two-pointer scan). The dominant term is O(n 
2
 ).
Space	O(
logn) to O(n)	This depends on the implementation of the sorting algorithm used. std::sort in C++ is typically an IntroSort, which has a space complexity of O(
logn). The space for the result vector is not counted towards auxiliary space complexity.

Export to Sheets
🏷️ Tags
#TwoPointers #Sorting #Array #LeetCode-Medium
