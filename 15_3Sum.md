# ğŸ”¢ LeetCode 15: 3Sum

![LeetCode](https://img.shields.io/badge/LeetCode-15-blue?style=for-the-badge&logo=leetcode)
![Difficulty](https://img.shields.io/badge/Difficulty-Medium-yellow?style=for-the-badge)
![Topics](https://img.shields.io/badge/Topics-Two%20Pointers%2C%20Sorting-brightgreen?style=for-the-badge)

---

## ğŸ“˜ Problem Statement

> Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.
>
> **Notice** that the solution set must not contain duplicate triplets.

---

## ğŸ“¥ Example Inputs

### âœ… Example 1:

**Input:**
```cpp
nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: The distinct triplets [-1, -1, 2] and [-1, 0, 1] sum to zero. The order of triplets in the output doesn't matter.
```
---
```
âœ… Example 2:
Input:

nums = [0,1,1]
Output: []
Explanation: No triplet sums to zero.
```
---
```
âœ… Example 3:
Input:

nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums to zero.

```

ğŸ“Œ Constraints
3 <= nums.length <= 3000

-10^5 <= nums[i] <= 10^5

---

ğŸ’¡ Pattern & Approach
The problem asks for unique triplets that sum to zero. A brute-force approach with three nested loops would be O(n 
3
 ), which is too slow given the constraints. A more optimal approach is Sort + Two Pointers.

The Logic
The core idea is to reduce the problem from finding three numbers to finding two. By fixing one number (a), the problem becomes finding two other numbers (b and c) such that b + c = -a. This "Two Sum" subproblem can be solved efficiently on a sorted array.

Sort the Array: The crucial first step is to sort the input array nums. This allows us to use the two-pointer technique and easily handle duplicates.

Outer Loop (Fixing a): Iterate through the sorted array with a pointer i from the beginning. nums[i] will be our fixed number a.

Two-Pointer Subproblem (Finding b and c): For each nums[i], we need to find nums[j] + nums[k] == -nums[i]. We can do this with two pointers:

Initialize a left pointer j at i + 1.

Initialize a right pointer k at the end of the array (n - 1).

Narrowing the Window: In a while (j < k) loop, calculate the sum S = nums[i] + nums[j] + nums[k].

If S == 0: ğŸ¯ We found a valid triplet! Add {nums[i], nums[j], nums[k]} to our result. Then, we must move our pointers and skip duplicates to avoid adding the same triplet again.

If S < 0: The sum is too small. Since the array is sorted, we need a larger value. We move the left pointer j to the right (j++).

If S > 0: The sum is too large. We need a smaller value. We move the right pointer k to the left (k--).

Duplicate Handling: This is critical for meeting the problem's requirements.

Outer Loop Duplicates: After finishing the two-pointer loop for a given i, we must skip over all subsequent identical values of nums[i] to avoid processing the same starting number multiple times.

Inner Loop Duplicates: After finding a valid triplet, we must advance j and k past any duplicates to ensure the next potential triplet is unique.

ğŸƒâ€â™‚ï¸ Dry Run
Let's trace the algorithm with nums = [-1,0,1,2,-1,-4].

1. Sorted Array: [-4, -1, -1, 0, 1, 2]

i	nums[i]	j	nums[j]	k	nums[k]	sum	Action & Skips	Result
0	-4	1	-1	5	2	-3	sum < 0, j++	[]
0	-4	2	-1	5	2	-3	sum < 0, j++	[]
0	-4	3	0	5	2	-2	sum < 0, j++	[]
0	-4	4	1	5	2	-1	sum < 0, j++	[]
-	-	5	-	5	-	-	j not < k. End i=0 loop.	-
1	-1	2	-1	5	2	0	Found [-1, -1, 2]. j++, k--.	[[-1,-1,2]]
1	-1	3	0	4	1	0	Found [-1, 0, 1]. j++, k--.	[[-1,-1,2], [-1,0,1]]
-	-	4	-	3	-	-	j not < k. End i=1 loop.	-
2	-1	-	-	-	-	-	Skip i=2 as nums[2]==nums[1]	-
3	0	4	1	5	2	3	sum > 0, k--	-
-	-	4	-	4	-	-	j not < k. End i=3 loop.	-
-	-	-	-	-	-	-	Outer loop finishes.	[[-1,-1,2], [-1,0,1]]

Export to Sheets

---

ğŸ’» C++ Code
C++
```
#include <vector>
#include <algorithm>

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        int n = nums.size();
        
        // Step 1: Sort the array
        sort(nums.begin(), nums.end());
        
        // Step 2: Outer loop to fix the first element of the triplet
        for (int i = 0; i < n - 2; i++) {
            
            // Step 3: Set up two pointers
            int j = i + 1;
            int k = n - 1;
            
            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                
                // Step 4.1: Found a triplet
                if (sum == 0) {
                    result.push_back({nums[i], nums[j], nums[k]});
                    j++;
                    k--;
                    
                    // Skip duplicates for the second element
                    while (j < k && nums[j] == nums[j - 1]) {
                        j++;
                    }
                    // Skip duplicates for the third element
                    while (j < k && nums[k] == nums[k + 1]) {
                        k--;
                    }
                } 
                // Step 4.2: Sum is too large, need to decrease it
                else if (sum > 0) {
                    k--;
                } 
                // Step 4.3: Sum is too small, need to increase it
                else { // sum < 0
                    j++;
                }
            }
            
            // Step 5: Skip duplicates for the first element
            // This moves `i` to the last occurrence of the current number
            // to avoid redundant checks in the next iteration.
            while (i < n - 2 && nums[i] == nums[i + 1]) {
                i++;
            }
        }
        
        return result;
    }
};

```

---
ğŸ“ˆ Time & Space Complexity
Complexity	Value	Justification
Time	O(n 
2
 )	The initial sort takes O(n
logn). The nested loops run in O(n 
2
 ) time (O(n) for the outer loop, and O(n) for the two-pointer scan). The dominant term is O(n 
2
 ).
Space	O(
logn) to O(n)	This depends on the implementation of the sorting algorithm used. std::sort in C++ is typically an IntroSort, which has a space complexity of O(
logn). The space for the result vector is not counted towards auxiliary space complexity.

Export to Sheets
ğŸ·ï¸ Tags
#TwoPointers #Sorting #Array #LeetCode-Medium
